"""Safety limits configuration and enforcement for Nova CI-Rescue."""

from dataclasses import dataclass
from typing import Optional, Tuple
from pathlib import Path


@dataclass
class SafetyLimits:
    """Configuration for safety limits."""
    
    # Patch size limits
    max_files_per_patch: int = 10
    max_lines_per_patch: int = 10000
    max_lines_per_file: int = 10000
    
    # Protected paths
    protected_paths: list[str] = None
    
    # Enforcement mode
    enforce_limits: bool = True  # If False, only warn; if True, halt execution
    
    def __post_init__(self):
        if self.protected_paths is None:
            self.protected_paths = [
                '.github/',
                'setup.py',
                'pyproject.toml',
                '.env',
                'requirements.txt',
                'poetry.lock',
                'Pipfile.lock',
                'package.json',
                'package-lock.json',
                'yarn.lock',
                'Gemfile.lock',
                'Cargo.lock',
                'go.sum',
            ]


def validate_patch_safety(
    patch: str, 
    limits: SafetyLimits,
    whole_file_mode: bool = False
) -> Tuple[bool, Optional[str]]:
    """
    Validate if a patch meets safety limits.
    
    Args:
        patch: The patch text to validate
        limits: Safety limits configuration
        whole_file_mode: Whether this is a whole-file replacement
        
    Returns:
        Tuple of (is_safe, error_message)
    """
    if not patch:
        return False, "Empty patch"
    
    patch_lines = patch.split('\n')
    
    if whole_file_mode:
        # For whole file replacements
        files_touched = sum(1 for line in patch_lines if line.startswith('FILE_REPLACE:'))
        
        if files_touched > limits.max_files_per_patch:
            msg = f"Too many files modified ({files_touched} > {limits.max_files_per_patch})"
            return not limits.enforce_limits, msg if limits.enforce_limits else None
        
        # Check protected paths
        for line in patch_lines:
            if line.startswith('FILE_REPLACE:'):
                file_path = line[13:].strip()
                for protected in limits.protected_paths:
                    if protected in file_path:
                        msg = f"Patch modifies protected file: {file_path}"
                        return not limits.enforce_limits, msg if limits.enforce_limits else None
                        
        # Check individual file sizes
        current_file_lines = 0
        for line in patch_lines:
            if line.startswith('FILE_REPLACE:'):
                if current_file_lines > limits.max_lines_per_file:
                    msg = f"File too large ({current_file_lines} > {limits.max_lines_per_file} lines)"
                    return not limits.enforce_limits, msg if limits.enforce_limits else None
                current_file_lines = 0
            else:
                current_file_lines += 1
                
    else:
        # For normal patches
        files_touched = sum(1 for line in patch_lines if line.startswith('+++ b/'))
        added_lines = sum(1 for line in patch_lines if line.startswith('+') and not line.startswith('+++'))
        removed_lines = sum(1 for line in patch_lines if line.startswith('-') and not line.startswith('---'))
        total_changes = added_lines + removed_lines
        
        # Check total patch size
        if len(patch_lines) >= 1000:
            msg = f"Patch too large ({len(patch_lines)} lines)"
            return not limits.enforce_limits, msg if limits.enforce_limits else None
            
        # Check files touched
        if files_touched > limits.max_files_per_patch:
            msg = f"Too many files modified ({files_touched} > {limits.max_files_per_patch})"
            return not limits.enforce_limits, msg if limits.enforce_limits else None
            
        # Check lines changed
        if total_changes > limits.max_lines_per_patch:
            msg = f"Too many lines changed ({total_changes} > {limits.max_lines_per_patch})"
            return not limits.enforce_limits, msg if limits.enforce_limits else None
        
        # Check protected paths
        for line in patch_lines:
            if line.startswith('+++ b/') or line.startswith('--- a/'):
                for protected in limits.protected_paths:
                    if protected in line:
                        msg = f"Patch modifies protected path: {line}"
                        return not limits.enforce_limits, msg if limits.enforce_limits else None
    
    return True, None


def load_safety_limits(config_path: Optional[Path] = None) -> SafetyLimits:
    """
    Load safety limits from configuration.
    
    Args:
        config_path: Optional path to config file
        
    Returns:
        SafetyLimits instance
    """
    # For now, return defaults. Could be extended to load from YAML/JSON
    return SafetyLimits()
